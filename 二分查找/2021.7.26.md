##44.[排列硬币](https://leetcode-cn.com/problems/arranging-coins/submissions/)
暴力法
时间复杂度O(n)
空间复杂度O(1)
```java
class Solution {
    public int arrangeCoins(int n) {
        int i = 1;
        if(n == 0 || n == 1){return n;}
        while(n >= i){
            n = n-i;
            i++;
        }
        return i-1;
    }
}
```
二分查找（边界的基本功）
其实也是利用公式（a1+an）*n/2 an = a1+(n-1)*d
d =1 a1 =1 --->
(1+n)*n/2这个n肯定实在[0,n]之间有一个最接近的值
时间复杂度
```java
class Solution {
    public int arrangeCoins(int n) {
    //说到底再[0,N]之间肯定有一个数满足“最接近”n(不一定是完全等于)
    long left = 0;
    long right = n;
    if(n == 0){return 0;}
 
    if(n < 3){return 1;}
    while(left <= right){
        long mid  = (left+right)/2;
        long sum = (mid+1)*mid/2;
        
        if(sum == n){
            return (int)mid;
        }
        if(sum < n){
           //
            left = mid+1;
        }
        if(sum > n){
            right = mid-1;
        }
    }
    return (int)left-1;
    }
}
```
##50.[ Pow(x, n)](https://leetcode-cn.com/problems/powx-n/submissions/)
时间复杂度O(logN)栈
空间复杂度O(logN):递归是logn层栈空间
```java
class Solution {
    public double myPow(double x, int n) {
        //具体就是每次循环就是直接把之前的相乘
        //可以节省很多时间不用1，2，3，1，2，4，8
        //这里要注意一个就是n取-的最大我直接变成正的会过界
         long N = n;
        return N > 0?quickPow(x,N):1.0/quickPow(x,-N);
        
    }
    public double quickPow(double x, long N){
        if(x == 1.0 || N == 0){return 1;}
        //递归/2
        double res = quickPow(x,N/2);
        return N % 2 == 0?res*res:res*res*x;
    }
        
}
```
这个解法真是放在二进制，就是米奇妙妙屋秒到姥姥家了
时间复杂度0(logN)
空间复杂度o(logN)
```java

class Solution {
    public double myPow(double x, int n) {
        //具体就是每次循环就是直接把之前的相乘
        //可以节省很多时间不用1，2，3，1，2，4，8
        //这里要注意一个就是n取-的最大我直接变成正的会过界
         long N = n;
        return N > 0?quickPow(x,N):1.0/quickPow(x,-N);
        
    }
    //迭代的思路我们不妨用二进制的思想来理解，就是x^77次方就是x^64*x^8*x^4*x^1--->1001101=77
    public double quickPow(double x, long N){
        if(x == 1.0 || N == 0){return 1;}
        //递归/2
        double ans = 1.0;
        double x_con = x;
        while(N > 0){
            if(N % 2 == 1){
                ans *= x_con;
            }
            x_con = x_con*x_con;
            N = N/2;
        }
        return ans;
        
    }
        
}
```